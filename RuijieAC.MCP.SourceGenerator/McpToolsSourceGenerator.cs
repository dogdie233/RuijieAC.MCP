using System.Linq;
using System.Threading;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;


namespace RuijieAC.MCP.SourceGenerator;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class McpToolsSourceGenerator : IIncrementalGenerator
{
    private const string ExtClassName = "SGMcpServerBuilderExtensions";
    private const string ToolsMethodName = "WithToolsFromAssemblySourceGen";
    private const string PromptsMethodName = "WithPromptsFromAssemblySourceGen";
    private const string DeclarationScript = $$"""
                                             // <auto-generated/>
                                             using Microsoft.Extensions.DependencyInjection;
                                             using System.Diagnostics.CodeAnalysis;
                                             
                                             namespace ModelContextProtocol.Server;

                                             internal static partial class {{ExtClassName}} {
                                                 internal static partial IMcpServerBuilder {{ToolsMethodName}}(this IMcpServerBuilder builder);
                                                 
                                                 internal static partial IMcpServerBuilder {{PromptsMethodName}}(this IMcpServerBuilder builder);
                                                 
                                                 [UnconditionalSuppressMessage("Trimming", "IL2026:Members annotated with 'RequiresUnreferencedCodeAttribute' require dynamic access otherwise can break functionality when trimming application code", Justification = "<Pending>")]
                                                 private static void WithTool2(IMcpServerBuilder builder,
                                                    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods |
                                                        DynamicallyAccessedMemberTypes.NonPublicMethods |
                                                        DynamicallyAccessedMemberTypes.PublicConstructors)] Type t) {
                                                     builder.WithTools([t]);
                                                 }
                                                 
                                                 [UnconditionalSuppressMessage("Trimming", "IL2026:Members annotated with 'RequiresUnreferencedCodeAttribute' require dynamic access otherwise can break functionality when trimming application code", Justification = "<Pending>")]
                                                 private static void WithPrompt2(IMcpServerBuilder builder,
                                                    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods |
                                                        DynamicallyAccessedMemberTypes.NonPublicMethods |
                                                        DynamicallyAccessedMemberTypes.PublicConstructors)] Type t) {
                                                     builder.WithPrompts([t]);
                                                 }
                                             }
                                             """;
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(initializationContext =>
        {
            initializationContext.AddSource("SGMcpServerBuilderExtensions.Declaration.g.cs", DeclarationScript);
        });

        var tools = context.SyntaxProvider.ForAttributeWithMetadataName(
            "ModelContextProtocol.Server.McpServerToolTypeAttribute",
            (node, _) => node.IsKind(SyntaxKind.ClassDeclaration) || node.IsKind(SyntaxKind.RecordDeclaration),
            GetFullname).Collect();

        var prompts = context.SyntaxProvider.ForAttributeWithMetadataName(
            "ModelContextProtocol.Server.McpServerPromptTypeAttribute",
            (node, _) => node.IsKind(SyntaxKind.ClassDeclaration) || node.IsKind(SyntaxKind.RecordDeclaration),
            GetFullname).Collect();
            
        context.RegisterImplementationSourceOutput(tools, (productionContext, arr) =>
        {
            var body = string.Join("\n", 
                arr.Select(type => $"WithTool2(builder, typeof({type}));")
            );
            productionContext.AddSource("SGMcpServerBuilderExtensions.ToolImplementation.g.cs",
                $$"""
                // <auto-generated/>
                using Microsoft.Extensions.DependencyInjection;
                using System.Diagnostics.CodeAnalysis;
                
                namespace ModelContextProtocol.Server;

                internal static partial class {{ExtClassName}} {
                    internal static partial IMcpServerBuilder {{ToolsMethodName}}(this IMcpServerBuilder builder) {
                        {{body}}
                        return builder;
                    }
                }
                """);
        });
        
        context.RegisterImplementationSourceOutput(prompts, (productionContext, arr) =>
        {
            var body = string.Join("\n",
                arr.Select(type => $"WithPrompt2(builder, typeof({type}));")
            );
            productionContext.AddSource("SGMcpServerBuilderExtensions.PromptImplementation.g.cs",
                $$"""
                // <auto-generated/>
                using Microsoft.Extensions.DependencyInjection;
                using System.Diagnostics.CodeAnalysis;
                
                namespace ModelContextProtocol.Server;

                internal static partial class {{ExtClassName}} {
                    internal static partial IMcpServerBuilder {{PromptsMethodName}}(this IMcpServerBuilder builder) {
                        {{body}}
                        return builder;
                    }
                }
                """);
        });
        return;

        string GetFullname(GeneratorAttributeSyntaxContext syntaxContext, CancellationToken ct)
        {
            var ns = syntaxContext.TargetSymbol.ContainingNamespace;
            var name = syntaxContext.TargetSymbol.Name;
            return $"global::{(ns?.IsGlobalNamespace ?? true ? "" : ns.Name + ".")}{name}";
        }
    }
}